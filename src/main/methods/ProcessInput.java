package main.methods;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class ProcessInput {

	private static String newLine = System.getProperty("line.separator");

	
	/*
	 * Extract inputed words into ArrayList
	 * Recognizes words based on variable wordSeparator (newline is considered as word separator.)
	 * Blank words are eliminated
	 * Duplicates are not eliminated
	 * String input can't be null
	 */ 
		public static ArrayList<String> extractInput(String input ,char wordSeparator){
			ArrayList<String> returnedWords = new ArrayList<String>();
			String tempWord = "";
			char currentChar;
			int inputLength = input.length();

			if (inputLength == 0) {
				Log.write("Input is empty!" , 'W');
				return null;
			}
			
			
			for (int i=0; i<inputLength; i++) {
				currentChar = input.charAt(i);
				if (currentChar!=wordSeparator && !compareCharAndStringForNewline(currentChar, newLine) )
					tempWord+=input.charAt(i);
				else{
					if (tempWord.length()>0)
						returnedWords.add(tempWord);
					else
						Log.writeDebug("Skipping empty word (you probably typed word separator twice)..." );
					
					tempWord = "";
				}
			}
			
			//Add last word if there is NO newline at the end
			if ( !compareCharAndStringForNewline( input.charAt( inputLength-1 ) , newLine) )
				returnedWords.add(tempWord);
			
			Log.writeDebug("Extracted input: " + Arrays.toString(returnedWords.toArray()) );
				
			return returnedWords;
		}
	
		
		
		static boolean compareCharAndStringForNewline( char charInput , String stringInput ){
			String temp = Character.toString(charInput);
			//Check if contains because newline(stringInput) can be 2 chars (on windows \r\n)
			if ( stringInput.contains(temp)){
				return true;
			}else{
				return false;
			}
		}

	
	
	
	/*
	 * Returns a string of all characters that are between char 'between'
	 * Example input is: word\\ab"prefix" ,and between is '"'
	 * then the returned characters are 'prefix'
	 * Duplicates are not eliminated (we called other method to do it)
	 * If char between doesn't exist it returns empty string ""
	 * If there is an odd number of chars between it returns empty string ""
	 */
	public static String getCharactersFromOptions(String text, char between){
		int i;
		int j;
		String temp = "";
		String tempChars = "";
		int length = text.length();
		int tempLength;

		if ( !(text != null && !text.isEmpty()) )
			return "";

		int count = text.length() - text.replace( String.valueOf(between), "").length();
		if ( (count & 1) != 0 ){
			Log.write("There can't be an odd number of '"+between+"' characters!" , 'E' );
			return "";
		}

		for ( i=0; i<length; i++ ){
			if ( text.charAt(i) == between ){
				i++;
				while ( (i)<length && text.charAt(i) != between ){
					temp += text.charAt(i);
					i++;
				}
			}
			
			tempLength = temp.length();
			if ( tempLength>0 )
				for ( j=0; j<tempLength ;j++ )
					tempChars += temp.charAt(j);

			temp = "" ;
		}
			
		return removeDuplicatesString(tempChars);
	}
	
	
	/*
	 * Removes all duplicate chars from input string
	 */
	private static String removeDuplicatesString( String text ){
		char[] chars = text.toCharArray();
		Set<Character> charSet = new LinkedHashSet<Character>();
		for (char c : chars) {
		    charSet.add(c);
		}

		StringBuilder sb = new StringBuilder();
		for (Character character : charSet) {
		    sb.append(character);
		}
		
		return sb.toString();
	}
	
	
	
	
	
	/*
	 * Build words from options
	 * NOTE:
	 * Total number of generated words is: X * Y
	 * Where X is number of words generated by combinations2D and Y same but from heapPermutation
	 * Example: Input is {{"sad","SAD"},{"najebo","NAJEBO"},{"sam","SAM"},{"test","TEST", "Test", "ayy"}}
	 * X would then be 2*2*2*4 = 32 
	 * Y would be 4! (1*2*3*4) because we have 4 blocks (4 words that make a sentence)
	 * Total = 768
	 */	
		
	//int Y = inputWords.size(); daje nullPointer exception ako je input prazan		
	public static List<List<String>> buildWords( ArrayList<String> inputWords , char combiningSeparator, char optionSeparator){
		int i;
		int X;
		int Y = inputWords.size();
		List<List<String>> tempOutput = new ArrayList<List<String>>();
		
		//Add Y words and start adding words and their options
		for( i=0; i<Y; i++){
			tempOutput.add(new ArrayList<String>());
			extractWords( tempOutput, i, inputWords.get(i).toString(), combiningSeparator, optionSeparator );
		}
		
		Log.writeDebug( "Base words that were extracted from input(without their options):" );
		for( i=0; i<Y; i++){
			for (String value : tempOutput.get(i)) {
				Log.writeDebug( (i+1) + ":" + value );
			}
		}
		
		return tempOutput;
	}
	
	
	
	
	/*
	 * Extract words from string
	 */
	
	public static void extractWords( List<List<String>> inputList , int index , String extractString , char combiningSeparator, char optionSeparator ){
		String baseString;
		String optionString;
		int indexCombining = extractString.indexOf(combiningSeparator);

		if( indexCombining!=-1 ){
			/*
			 * There is combining separator in string so we will break the word
			 * in 2 parts and call this function again with each part
			 */
		   Log.writeDebug("Found combining separator in string: " + extractString );
		   String tempInput = extractString ;
		   StringBuilder temp = new StringBuilder();
		   for( int i=0; i<tempInput.length(); i++ ){
			   if( tempInput.charAt(i)==combiningSeparator ){
				   extractWords( inputList, index, temp.toString() , combiningSeparator, optionSeparator );
				   temp = new StringBuilder();

			   }else if( i==tempInput.length()-1 ){
				   temp.append( tempInput.charAt(i) );
				   extractWords( inputList, index, temp.toString() , combiningSeparator, optionSeparator );
				   //temp = new StringBuilder();
			   }else{
				   temp.append( tempInput.charAt(i) );
			   }
		   }
		   return;
		}else{
			/*
			 * There is NO combining separator in word meaning word is single
			 * Now we look if word has additional options or not
			 */
			int indexOption = extractString.indexOf(optionSeparator);
			if( indexOption!=-1 ){
				/*
				 * There are options in the word so we will have to generate new words
				 * based on those options and base string (which is an original word)
				 */
				baseString = extractString.substring(0, indexOption);
				optionString = extractString.substring(indexOption);
				inputList.get(index).add(baseString);
				/*
				 * Split option string to multiple parts then call function for every option part
				 * We used optionSeparatorDouble because option separator is a double char in the program
				 */
				String optionSeparatorDouble = optionSeparator+""+optionSeparator;
				String[] word = optionString.split(optionSeparatorDouble);
				word = removeEmpty(word);
				
				Log.writeDebug("Printing option array for word: '" + extractString + "' in format (ID:option) :" );
				for(int k =0; k<word.length;k++)
					Log.writeDebug( k + ": " + word[k] );
				
					for(String optionPart: word){
						/*
						 * Eliminate empty words produced by optionString.split
						 */
						//log.append("Test:"+optionPart+"\n");
						//if(!optionPart.isEmpty()){
							/*
							 * Before calling the option method first extract sub-options
							 */
						Log.writeDebug("Spliting:'"+optionPart+"' to suboptions!" );
							String[] subOptions = optionPart.split( ""+optionSeparator );
							/*
							 * Now remove empty words from sub-options produced by optionString.split
							 */
							subOptions = removeEmpty(subOptions);
							Log.writeDebug("Printing suboptions (ID:suboption) where ID=0 means base option:" );
							for(int k =0; k<subOptions.length;k++)
								Log.writeDebug(k+":"+subOptions[k] );
							/*
							 * String in first index of finalSubOptions is the option while rest are subOptions
							 */
							//Log.writeDebug("baseString: "+baseString+"  ,optionPart:"+optionPart+"  ,subOptions: (printed above)");
							WordOptions.extractOptions( inputList, index, baseString, subOptions );
						//}
					}
				return;
			}else{
				/*
				 * There are no options in word so we just add it to the list
				 */
				Log.writeDebug("No options in word:"+extractString );
				inputList.get(index).add(extractString);
				return;
			}
		}
		
	}




	/*
	 * Eliminate empty words in string array
	 * Words are considered empty if they are null or have 0 characters
	 */
	
	public static String[] removeEmpty(String[] input){
		List<String> list = new ArrayList<String>(Arrays.asList(input));
		list.removeAll(Arrays.asList("", null));
		return list.toArray(new String[0]);
	}
	

}
